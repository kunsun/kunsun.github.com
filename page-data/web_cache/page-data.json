{"componentChunkName":"component---src-templates-blog-post-js","path":"/web_cache","result":{"data":{"markdownRemark":{"html":"<p>说到底缓存最重要的核心就是解决：</p>\n<ol>\n<li>什么时候使用缓存</li>\n<li>什么时候更新缓存</li>\n</ol>\n<h2>强缓存</h2>\n<h3>HTTP1.1</h3>\n<p>服务端使用 Cache-control 这个响应头</p>\n<ol>\n<li>private：表示私有缓存，不能被共有缓存代理服务器缓存，不能在用户间共享，可被用户的浏览器缓存。</li>\n<li>public：表示共有缓存，可被代理服务器缓存，比如 CDN，允许多用户间共享</li>\n<li>max-age：值以秒为单位，表示缓存的内容会在该值后过期</li>\n<li>no-cache：需要使用协商缓存，协商缓存的内容我们后面介绍。注意这个字段并不表示不使用缓存</li>\n<li>no-store：所有内容都不会被缓存</li>\n</ol>\n<p>HTTP 规定，如果 Cache-control 的 max-age 和 Expires 同时出现，那么 max-age 的优先级更高，他会默认覆盖掉 expires。</p>\n<h2>协商缓存</h2>\n<p>从优化的角度来说，我们真正应该关心的是服务器端文件是否已经发生了变化。此时我们需要用到协商缓存策略。</p>\n<ol>\n<li>Last-Modified，If-Modified-Since</li>\n<li>ETag、If-None-Match</li>\n</ol>\n<p>分析第一种：\nLast-Modified 标注的最后修改只能精确到秒级</p>\n<ol>\n<li>浏览器第一次请求资源，服务端在返回资源的响应头中加入 Last-Modified 字段，这个字段表示这个资源在服务器上的最近修改时间</li>\n<li>浏览器收到响应，并记录 Last-Modified 这个响应头的值为 T</li>\n<li>当浏览器再次向服务端请求该资源时，请求头加上 If-Modified-Since 的 header，这个 If-Modified-Since 的值正是上一次请求该资源时，后端返回的 Last-Modified 响应头值 T</li>\n</ol>\n<p>分析第二种：\n服务器集群来处理请求的网站来说， Etag 的匹配概率会大幅降低。所在在这种情况下，使用 Etag 来处理缓存，反而会有更大的开销。</p>\n<ol>\n<li>浏览器第一次请求资源，服务端在返回资源的响应头中加入 Etag，Etag 能够弥补 Last-Modified 的问题，因为 Etag 的生成过程类似文件 hash 值，Etag 是一个字符串，不同文件内容对应不同的 Etag 值</li>\n<li>浏览器收到响应，记录 Etag 这个响应头的值为 E</li>\n<li>浏览器再次跟服务器请求这个资源时，在请求头上加上 If-None-Match，值为 Etag 这个响应头的值 E</li>\n<li>服务端再次收到请求，根据请求头 If-None-Match 的值 E，根据资源生成一个新的 ETag，对比 E 和新的 Etag：如果两值相同，则说明资源没有变化，返回 304 Not Modified，同时携带着新的 ETag 响应头；如果两值不同，就正常返回资源内容，这时也更新 ETag 响应头</li>\n<li>浏览器收到 304 的响应后，就会从缓存中加载资源</li>\n</ol>\n<p>优先级：\nCache-Control > Expires > ETag > Last-Modified</p>\n<ol>\n<li>当用户 Ctrl + F5 强制刷新网页时，浏览器直接从服务器加载，跳过强缓存和协商缓存   相当于在chrome控制台打开no-cache选项</li>\n<li>当用户仅仅敲击 F5 刷新网页时，跳过强缓存，但是仍然会进行协商缓存过程    </li>\n</ol>\n<h2>1. 如何禁止浏览器不缓存静态资源</h2>\n<p>设置请求头：</p>\n<pre class=\"grvsc-container material-theme\" data-language=\"js\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"mtk4\">Cache</span><span class=\"mtk8\">-</span><span class=\"mtk1\">Control: </span><span class=\"mtk4\">no</span><span class=\"mtk8\">-</span><span class=\"mtk4\">cache</span><span class=\"mtk1\">, </span><span class=\"mtk4\">no</span><span class=\"mtk8\">-</span><span class=\"mtk4\">store</span><span class=\"mtk1\">, </span><span class=\"mtk4\">must</span><span class=\"mtk8\">-</span><span class=\"mtk4\">revalidate</span></span></code></pre>\n<p>增加版本号：</p>\n<p>meta标签</p>\n<pre class=\"grvsc-container material-theme\" data-language=\"html\" data-index=\"1\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"mtk1\">&lt;</span><span class=\"mtk4\">meta</span><span class=\"mtk1\"> </span><span class=\"mtk7\">http-equiv</span><span class=\"mtk1\">=</span><span class=\"mtk6\">&quot;Cache-Control&quot;</span><span class=\"mtk1\"> </span><span class=\"mtk7\">content</span><span class=\"mtk1\">=</span><span class=\"mtk6\">&quot;no-cache, no-store, must-revalidate&quot;</span><span class=\"mtk1\">/&gt;</span></span></code></pre>\n<h2>2. 题目二：设置以下 request/response header 会有什么效果？</h2>\n<pre class=\"grvsc-container material-theme\" data-language=\"js\" data-index=\"2\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"mtk4\">cache</span><span class=\"mtk8\">-</span><span class=\"mtk1\">control: </span><span class=\"mtk4\">max</span><span class=\"mtk8\">-</span><span class=\"mtk4\">age</span><span class=\"mtk8\">=</span><span class=\"mtk7\">0</span></span></code></pre>\n<p>因为 max-age 设置为 0，所以浏览器必须发请求重新验证资源。这时候会走协商缓存机制，可能返回 200 或者 304。</p>\n<h2>3. 题目三：设置以下 request/response header 会有什么效果？</h2>\n<pre class=\"grvsc-container material-theme\" data-language=\"js\" data-index=\"3\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"mtk4\">cache</span><span class=\"mtk8\">-</span><span class=\"mtk1\">control: </span><span class=\"mtk4\">no</span><span class=\"mtk8\">-</span><span class=\"mtk4\">cache</span></span></code></pre>\n<p>因为设置 no-cache，所以浏览器必须发请求重新验证资源。这时候会走协商缓存机制。</p>\n<h2>4. 题目四：除了上述方式，还有哪种方式可以设置浏览器必须发请求重新验证资源，走协商缓存机制？</h2>\n<pre class=\"grvsc-container material-theme\" data-language=\"js\" data-index=\"4\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"mtk4\">cache</span><span class=\"mtk8\">-</span><span class=\"mtk1\">control: </span><span class=\"mtk4\">must</span><span class=\"mtk8\">-</span><span class=\"mtk4\">revalidate</span></span></code></pre>\n<h2>5. 题目五：设置以下 request/response header 会有什么效果？</h2>\n<pre class=\"grvsc-container material-theme\" data-language=\"js\" data-index=\"5\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"mtk4\">Cache</span><span class=\"mtk8\">-</span><span class=\"mtk1\">Control: </span><span class=\"mtk4\">max</span><span class=\"mtk8\">-</span><span class=\"mtk4\">age</span><span class=\"mtk8\">=</span><span class=\"mtk7\">60</span><span class=\"mtk1\">, </span><span class=\"mtk4\">must</span><span class=\"mtk8\">-</span><span class=\"mtk4\">revalidate</span></span></code></pre>\n<p>如果资源在 60s 内再次访问，走强缓存，可以直接返回缓存资源内容；如果超过 60s，则必须发送网络请求到服务端，去验证资源的有效性。</p>\n<h2>6. 题目六：据你的经验，为什么大厂都不怎么用 Etag？</h2>\n<p>很可能被分配到不同的服务器来相应，而根据 ETag 的计算原理，不同的服务器，有可能在资源内容没有变化的情况下，计算出不一样的 Etag，而使得缓存失效。\n而且 Etag 计算较为复杂，所以可能会使得服务端响应变慢。</p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n  }\n  \n  .grvsc-code {\n    display: inline-block;\n    min-width: 100%;\n  }\n  \n  .grvsc-line {\n    display: inline-block;\n    box-sizing: border-box;\n    width: 100%;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-line-highlighted {\n    background-color: var(--grvsc-line-highlighted-background-color, transparent);\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, transparent);\n  }\n  \n  .material-theme {\n    background-color: #282c34;\n    color: #abb2bf;\n  }\n  .material-theme .mtk4 { color: #E06C75; }\n  .material-theme .mtk8 { color: #56B6C2; }\n  .material-theme .mtk1 { color: #ABB2BF; }\n  .material-theme .mtk7 { color: #D19A66; }\n  .material-theme .mtk6 { color: #98C379; }\n</style>","frontmatter":{"date":"February 02, 2021","path":"/web_cache","title":"Web 缓存"}}},"pageContext":{}},"staticQueryHashes":[]}